запускать вседа из папки infra
docker compose -f docker-compose.dev.yml up -d

Остановка
docker compose -f docker-compose.dev.yml down

1. После внедрения kafka переходить к миграциям
   synchronize: true в TypeORM — для dev ок, но при подключении Kafka и усложнении системы лучше переходить к миграциям (иначе можно словить неожиданные изменения схемы).
   userId приходит из body — это норм временно, но когда подключишь Gateway/Auth, лучше брать userId из токена/контекста.

Когда лучше подключать gRPC относительно Kafka
Нормальный план:

Kafka для событий (UserCreated, OrderCreated, StockReserved…)
gRPC для синхронных запросов (получить продукт, проверить наличие, получить профиль)

Примеры использования:

- OrderService вызывает ProductService через gRPC для проверки наличия товаров
- UserService вызывает OrderService через gRPC для получения истории заказов

Планирование:

- Сначала реализуем Kafka для асинхронного взаимодействия между сервисами
- Затем добавим gRPC для синхронных вызовов между микросервисами

Типичная архитектура:

- Kafka обрабатывает события: UserCreated, OrderCreated, PaymentProcessed
- gRPC используется для вызовов: getProduct(id), checkStock(productId, quantity), getUserProfile(userId)

Плюсы Kafka:

- Асинхронность и отказоустойчивость
- Хорошо подходит для событийной архитектуры
- Масштабируемость

Плюсы gRPC:

- Высокая производительность
- Строгая типизация
- Поддержка streaming

Рекомендации по использованию:

- Используйте Kafka для асинхронных событий и decoupling сервисов
- Используйте gRPC для синхронных вызовов внутри микросервисной архитектуры

Примеры сценариев:

- При создании заказа: OrderService публикует событие в Kafka, ProductService подписывается и обновляет 库存
- При проверке наличия: OrderService вызывает ProductService через gRPC для получения актуальных данных

Примечания:

- Kafka подходит для долгосрочных операций и обработки событий
- gRPC подходит для быстрых синхронных вызовов между сервисами

Дополнительно:

- Храните схемы protobuf в отдельной папке для каждого сервиса
- Используйте versioning для protobuf файлов
- Обеспечьте backward compatibility при изменении схем
- Регулярно тестируйте взаимодействие между сервисами
- Ведите документацию по API каждого сервиса
- Используйте инструменты для генерации клиентского кода из protobuf
- Автоматизируйте процесс генерации кода при изменении protobuf схем
