1. Роль cart-service и правила (зафиксируй до кода)
   Что делает корзина
   Хранит черновик покупки для пользователя: какие товары и в каком количестве.
   Дает API:
   добавить товар
   изменить количество
   удалить товар
   очистить корзину
   получить корзину
   Что корзина НЕ делает (чтобы не усложнять)
   Не хранит “истинные” цены и не отвечает за актуальность цены.
   Не оформляет заказ (это будет order-service).
   Не управляет оплатой/остатками.
   Главное архитектурное правило
   cart-service хранит только:
   userId
   productId
   quantity
   Всё остальное (цены/названия/скидки) можно “обогащать” позже через product-service.
2. Минимальный MVP: корзина в Redis
   Redis — идеальная первая реализация корзины: быстро, просто, соответствует реальному подходу.

2.1. Ключи в Redis (выбери 1 модель)
Вариант A (самый простой для старта): JSON в одном ключе

Ключ: cart:{userId}
Значение: JSON вида
{"items":[{"productId":1,"quantity":2},{"productId":5,"quantity":1}],"updatedAt":"..."}
Плюсы:

очень просто реализовать Минусы:
обновление позиции требует чтение→правка→запись
Вариант B (чуть “правильнее”): Redis Hash

Ключ: cart:{userId}
Поля hash: { productId: quantity }
Плюсы:

обновлять количество очень удобно Минусы:
получение корзины требует преобразования в массив
Для обучения рекомендую: Вариант A, потом (по желанию) перейдёшь на B.

2.2. TTL (время жизни корзины)
На MVP можно:

либо без TTL (корзина “вечная”)
либо TTL, например 7 дней (потренируешься) Важно: TTL — не обязателен. 3) REST API для корзины (чтобы тестировать руками)
Важно: у тебя уже есть globalPrefix('api'), значит все маршруты будут /api/....

Минимальные маршруты
GET /api/cart/:userId — получить корзину
POST /api/cart/:userId/items — добавить товар
body: { productId, quantity }
PATCH /api/cart/:userId/items/:productId — изменить количество
body: { quantity }
DELETE /api/cart/:userId/items/:productId — удалить позицию
DELETE /api/cart/:userId — очистить корзину
Правила валидации (сразу приучи себя)
userId — число/строка (как решишь, но единообразно)
productId — число
quantity — целое >= 1
(если прислали 0 — либо ошибка, либо трактовать как удалить позицию; выбери один вариант и зафиксируй) 4) Структура сервиса (NestJS-модули)
Сделай в стиле твоих сервисов (product-service, user-service):

CartModule
CartController
CartService
DTO: AddItemDto, UpdateItemDto
(опционально) CartRepository — тонкий слой поверх Redis, чтобы логика не “растекалась” 5) Подключение Redis в cart-service
У тебя уже есть Redis в инфраструктуре и в user-service есть RedisService.

Варианты, как поступить (выбери один)
Вариант A (быстрее): скопировать минимальную Redis-обвязку из user-service

Да, это дублирование, но для учебного проекта ок.
Вариант B (чуть лучше): вынести RedisModule в общий libs/ пакет

Это уже шаг в сторону “монорепо best practices”.
Можно сделать позже, когда корзина заработает.
Для старта рекомендую: Вариант A, но в план закладываем “потом вынести в общую библиотеку”.

6. Проверка MVP (ручные тест-сценарии)
   Перед интеграциями сделай чек-лист:

Сценарий 1: новая корзина
GET /api/cart/1 → пустая корзина
Сценарий 2: добавление
add {productId:10, quantity:2} → корзина содержит позицию
Сценарий 3: повторное добавление того же товара
add {productId:10, quantity:1} → либо суммируешь (станет 3), либо перезаписываешь (станет 1)
Выбери и зафиксируй. Для корзины чаще логично суммировать.
Сценарий 4: изменение количества
update quantity → значение меняется
Сценарий 5: удаление
delete item → позиции нет
Сценарий 6: очистка
delete cart → корзина пустая 7) Интеграция с product-service (после MVP)
Чтобы корзина выглядела как “магазин”, нужно показывать пользователю название и цену, но хранить их в корзине не обязательно.

7.1. Что делать на старте (простая версия)
GET /api/cart/:userId возвращает только productId и quantity
Клиент (или gateway) сам ходит в product-service за деталями
Это самый простой “микросервисный” подход.

7.2. Улучшение (обогащение на стороне cart-service)
Сделай эндпоинт:

GET /api/cart/:userId/view (или query ?expand=true) Он:
читает корзину из Redis
запрашивает товары из product-service
возвращает “красивый” ответ: name, price, quantity, subtotal
Сначала делай через REST (быстрее отладить), потом заменишь на gRPC.

8. Инфраструктура (docker-compose) и порты
   8.1. Порт
   Выбери порт под cart-service, например:

cart-service: 5003
8.2. Compose
добавить сервис cart-app-dev
подключить к redis
пробросить порт 5003:5003
volume как в других сервисах
8.3. Важное правило, чтобы не ловить конфликты
Если cart-service поднят в Docker — не запускай его локально на том же порту.
Если хочешь запускать локально — останови контейнер cart-service. 9) Переход к “оформлению” (стыковка с order-service)
Когда корзина работает, ты добавишь “перевод корзины в заказ”. Есть 2 подхода:

Вариант A (проще): order-service забирает корзину
order-service вызывает cart-service и получает items
создаёт заказ
после успеха вызывает cart-service очистить корзину
Вариант B (чуть “event-driven”): через Kafka
cart-service публикует CartCheckedOut
order-service подписывается и создаёт заказ
order-service публикует OrderCreated
cart-service подписывается и очищает корзину
Для тебя сейчас логичнее: Вариант A, Kafka подключим позже.

10. Что делать после того, как корзина готова
    Тогда ты уже готов к order-service, и он будет проще, потому что:

данные для заказа (items) уже есть
останется научиться “зафиксировать факт” и статусы
и дальше Kafka/gRPC станет намного понятнее
Вопрос перед стартом (важно)
Выбери, пожалуйста, 2 решения — и я подстрою план проверок под них:

Как хранить в Redis?
[A] один ключ с JSON
[B] Redis Hash
Как обрабатывать повторное добавление товара?
[A] суммировать quantity
[B] перезаписывать quantity
Статус
План для cart-service готов, без кода, можно начинать реализацию по шагам.
